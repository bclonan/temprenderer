
-- template 

<!-- Rich mode: only when #subtext exists AND not multiple -->
<BDropdown v-if="useRichSelect" class="w-100" variant="light" :disabled="disabled" no-caret menu-class="w-100"
    :toggle-class="['w-rich-select-toggle', { 'is-invalid': shouldShowValidation }]" @hidden="handleBlur">
    <!-- This is the "select box" face -->
    <template #button-content>
        <div class="d-flex justify-content-between align-items-start w-100">
            <div class="text-start flex-grow-1 min-w-0">
                <div class="fw-semibold text-truncate">
                    {{ selectedLabel }}
                </div>

                <!-- ✅ Subtext INSIDE the box -->
                <div class="small text-muted text-truncate">
                    <slot name="subtext" :value="inputValue" :option="selectedOption" />
                </div>
            </div>

            <span class="ms-2 text-muted" aria-hidden="true">▾</span>
        </div>
    </template>

    <!-- Placeholder item (mirrors your #first placeholder behavior) -->
    <BDropdownItem v-if="displayFirstSlot" @click="selectValue(customFirstSlotValue ?? '')">
        {{ localeBasedPlaceHolderText }}
    </BDropdownItem>

    <!-- Options -->
    <BDropdownItem v-for="opt in options" :key="String(opt[selectValueField])"
        @click="selectValue(opt[selectValueField])">
        {{ opt[selectTextField] }}
    </BDropdownItem>
</BDropdown>

<!-- Normal mode: your existing select stays untouched -->
<BFormSelect v-else ...your existing props/events...>
    <template #first>
        <option v-if="!multiple && displayFirstSlot" :value="customFirstSlotValue ?? ''">
            {{ localeBasedPlaceHolderText }}
        </option>
    </template>
</BFormSelect>


-- script adds 
import { computed, useSlots } from 'vue'
import { BDropdown, BDropdownItem } from 'bootstrap-vue-next'

const slots = useSlots()

// only use rich when slot provided + single select + not plaintext
const useRichSelect = computed(() =>
!!slots.subtext && !props.multiple && !isPlaintextComputed.value
)

const selectedOption = computed(() => {
const v = inputValue.value
return (props.options ?? []).find((o: any) => o?.[props.selectValueField] === v) ?? null
})

const selectedLabel = computed(() => {
const v = inputValue.value
if (v === '' || v === null || v === undefined) return localeBasedPlaceHolderText.value
return (
selectedOption.value?.[props.selectTextField] ??
localeBasedPlaceHolderText.value
)
})

function selectValue(val: any) {
handleInput(val)
handleChange(val)
// blur handled via @hidden
}


--- css 
.w-rich-select-toggle {
width: 100%;
min-height: 58px;
border: 1px solid var(--bs-border-color);
background: var(--bs-body-bg);
border-radius: 0 !important;
padding: .5rem .75rem;
text-align: left;
box-shadow: none !important;
}


<!-- usage --> 


<WDropDown v-model="dto.locationType" :options="locationTypeOptions">
  <template #subtext="{ value }">
    <span v-if="value === 'travel'">Travel for assignments</span>
    <span v-else-if="value === 'remote'">Work from anywhere</span>
    <span v-else>Work at a job site</span>
  </template>
</WDropDown>
